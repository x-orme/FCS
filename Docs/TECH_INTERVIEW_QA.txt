[K105A1 FCS 프로젝트 - 기술 면접/포트폴리오 대비 Q&A]
작성일: 2026-01-09
작성자: FCS 개발 엔지니어

================================================================================
Q1. [Architecture] 헤더 순환 참조(Circular Dependency) 문제를 어떻게 해결했나요?
--------------------------------------------------------------------------------
A: 프로젝트 초기에는 `ui.h`가 `fcs_math.h`를 포함하고, `fcs_math.h`가 다시 `ui.h`의 구조체를 필요로 하는 구조였습니다.
이로 인해 컴파일 시 "unknown type name" 에러가 발생했습니다.

이를 해결하기 위해 **가장 기초가 되는 데이터 타입**(`FCS_System_t`, `UTM_Coord_t` 등)만을 모해놓은 `fcs_common.h`라는 공용 헤더를 신설했습니다.
이 **"Data Structure Liberation (데이터 구조 해방)"** 전략을 통해,
모듈 간의 상호 의존성을 끊고 모든 모듈이 `fcs_common.h` 하나만 바라보는(Unidirectional) 깔끔한 계층 구조를 만들었습니다.

================================================================================
Q2. [Interrupt] UART 수신 처리에 왜 굳이 링 버퍼(Ring Buffer)를 사용했나요?
--------------------------------------------------------------------------------
A: 인터럽트 서비스 루틴(ISR)의 골든 룰은 **"짧고 빨라야 한다"**입니다.
초기 구현에서는 ISR 내부에서 들어온 문자를 `printf`로 에코백(Echo-back)하거나 복잡한 파싱 검사를 수행했습니다.
이때 사용자가 터미널에서 텍스트를 "붙여넣기"하여 고속(Burst)으로 데이터가 들어오자,
ISR 처리 시간이 길어져 다음 바이트를 수신하지 못하고 **Overrun Error**가 발생해 데이터가 깨졌습니다.

이를 해결하기 위해 `Producer-Consumer` 패턴의 **원형 버퍼(Ring Buffer)**를 도입했습니다.
- **Producer (ISR):** 들어온 데이터를 버퍼에 넣고(Head++) 즉시 리턴. (수 µs 소요)
- **Consumer (Main Loop):** 여유 있을 때 버퍼에서 데이터를 꺼내(Tail++) 파싱 및 처리.
이 방식으로 실시간성을 보장하면서도 데이터 무결성을 확보했습니다.

================================================================================
Q3. [Embedded C] volatile 키워드는 프로젝트 어디에 사용했나요?
--------------------------------------------------------------------------------
A: `main.c`에 선언된 UART 수신 버퍼의 인덱스 변수(`u_head`, `u_tail`)에 사용했습니다.
이 변수들은 **ISR(인터럽트)**과 **메인 루프**라는 두 개의 서로 다른 실행 흐름(Thread of Execution)에서 공유됩니다.

만약 `volatile`을 쓰지 않으면, 컴파일러 최적화(Optimization) 과정에서
"메인 루프에서는 이 변수를 수정하는 코드가 없네?"라고 판단하여 메모리를 다시 읽지 않고 레지스터 캐시 값을 계속 쓸 수 있습니다.
ISR이 값을 바꿔도 메인 루프는 이를 모르게 되는 심각한 버그를 막기 위해 `volatile`을 명시했습니다.

================================================================================
Q4. [Optimization] 임베디드에서 실수(Float) 연산과 출력을 어떻게 최적화했나요?
--------------------------------------------------------------------------------
A: Cortex-M4F(FPU 내장)를 사용하더라도 `printf("%f")` 함수는 매우 무겁습니다.
표준 라이브러리(newlib-nano)에서 이를 활성화하면 코드 사이즈가 수 KB 증가하고, 내부적으로 `malloc`과 과도한 스택을 사용합니다.

따라서 센서나 탄도 계산에는 `float/double`을 사용하여 정밀도를 유지하되,
사용자에게 보여주는 **입출력(I/O) 단계에서는 정수 기반 처리**를 했습니다.
- **입력:** "123.45" → 정수부(123)와 소수부(45)를 따로 파싱하여 합침.
- **출력:** 정수부와 소수부를 분리하여 `printf("%d.%02d", int_part, frac_part)`로 출력.
이로써 메모리 사용량을 최소화하면서도 사용자 경험을 동일하게 유지했습니다.

================================================================================
Q5. [Refactoring] 레거시 코드를 개선할 때 본인만의 철칙이 있나요?
--------------------------------------------------------------------------------
A: **"기능 변경 없는 스타일 통일(Style Standardization) 선행"** 입니다.
로직 수정과 스타일 수정이 섞이면 `git diff`가 지저분해져서, 내가 고친 게 "로직"인지 "공백"인지 리뷰하기 힘듭니다.
이번 프로젝트에서도 본격적인 구조 개선(함수 분리) 전에,
전체 파일의 들여쓰기를 2-Space로 통일하는 작업을 먼저 수행하고 커밋했습니다.
이 덕분에 이후의 리팩토링 커밋은 온전히 "로직의 변화"만을 보여줄 수 있었습니다.

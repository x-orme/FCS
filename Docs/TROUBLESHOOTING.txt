[K105A1 FCS 프로젝트 - 개발 트러블슈팅 로그]
작성일: 2026-01-09

================================================================================
No.1 | [HW/Sensor] BMP280 고장 진단: 통신은 되는데 값은 쓰레기?
--------------------------------------------------------------------------------
[문제 상황]
- `HAL_I2C_IsDeviceReady`는`HAL_OK`를 반환하며 장치 인식에 성공함.
- 그러나 온도/기압 데이터를 읽으면 터무니없는 값(온도 890도, 기압 0 등)이 나오거나 변동이 없음.

[디버깅 과정]
1. **통신 라인 분석:** 오실로스코프로 I2C 파형 확인 -> 클럭(SCL)과 데이터(SDA) 파형은 깨끗함. ACK도 정상 수신.
2. **레지스터 덤프:** ID 레지스터(0xD0)는 `0x58`로 정상. 하지만 보정 계수(0x88~0xA1)를 읽어보니 데이터 시트의 예시와 전혀 다른 패턴의 값이 들어있음.
3. **Raw Data 확인:** ADC 레지스터(0xF7) 값을 찍어보니 지속적으로 `0x80000` (Min/Invalid Value)이 반환됨.
   
[원인 및 결론]
- 통신 인터페이스(I2C 로직)는 살아있으나, 센서 내부의 **MEMS 다이어프램(압력 감지 소자)이 물리적으로 손상**된 것으로 판명.
- 모듈 교체 후 정상 범위(0x50000 대역)의 ADC 값 수신 확인. '통신 성공'이 '센서 정상'을 보장하지 않음을 배움.

================================================================================
No.2 | [Memory/Bug] 스택 오버플로우로 인한 '유령 커서' 현상
--------------------------------------------------------------------------------
[문제 상황]
- UI 메뉴에서 '위/아래' 버튼을 눌러도 커서가 움직이지 않거나, 갑자기 엉뚱한 위치로 점프함.
- 디버깅 결과 `ui_cursor_line` 변수 값이 버튼을 누를 때마다 0으로 초기화되거나 쓰레기 값으로 변함.

[원인 분석]
- `sprintf`로 화면 버퍼 문자열을 만드는 과정에서, 할당된 `char buffer[32]`보다 긴 문자열을 기록함.
- C언어는 배열 경계 검사를 안 하므로, 버퍼 뒤쪽에 위치한 **`ui_cursor_line` 지역 변수 등의 스택 메모리를 덮어씀 (Stack Corruption).**
- 특히 임베디드 환경에서 `%f` 포맷 포팅 시도 중 버퍼 사이즈 계산 착오가 주원인.

[해결 (Action)]
- 문자열 버퍼 크기를 `[64]`로 여유 있게 늘림.
- `snprintf`를 사용하여 버퍼 오버플로우를 원천 차단.
- 전역 변수와 스택 변수의 메모리 배치(Memory Layout)를 고려하여 중요 상태 변수 보호.

================================================================================
No.3 | [Comm/UART] 고속 입력 시 데이터 유실 (ISR Latency)
--------------------------------------------------------------------------------
[문제 상황]
- 터미널에서 `TGT:123,456` 명령어를 붙여넣기(Paste)하면 `TGT:123456` 처럼 콤마가 빠지거나 잘림.

[원인 분석]
- `HAL_UART_RxCpltCallback` 안에서 `printf`로 에코백을 수행함.
- `printf`는 수백 마이크로초(us) 이상 걸리는 무거운 함수. ISR이 안 끝나서 다음 데이터 수신 불가(Overrun).

[해결 (Action)]
- **Circular Buffer (Ring Buffer)** 구현.
- ISR에서는 `buffer[head] = data;`만 하고 즉시 종료. 처리는 메인 루프에서 수행.

================================================================================
No.4 | [Runtime/Lib] sscanf/sprintf의 실수(%f) 미지원
--------------------------------------------------------------------------------
[문제 상황]
- `sscanf(buf, "%f", &val)` 파싱 실패, `sprintf` 출력 불가.

[원인 분석]
- `newlib-nano` 라이브러리의 Float I/O 비활성화 (Flash 용량 절감 정책).

[해결 (Action)]
- 정수 기반 파싱/출력(Integer Arithmetic) 직접 구현. (메모리 절약 + 성능 향상)

================================================================================
No.5 | [Domain] 도북(Grid North) vs 진북(True North)
--------------------------------------------------------------------------------
[문제 상황]
- FCS 방위각 계산 결과가 상용 GPS 앱과 20~30mil 오차 발생.

[해결 (Action)]
- FCS는 군용 지도 표준인 **도북(UTM Grid)** 기준, 앱은 **진북** 기준임을 확인. FCS 계산이 맞음.

================================================================================
No.6 | [Compile] 헤더 중복 정의 (Multiple Definition)
--------------------------------------------------------------------------------
[문제 상황]
- `ui.h`, `fcs_math.h` 상호 참조 시 `multiple definition` 링커 에러.

[해결 (Action)]
- 헤더에는 `extern` 선언만 남기고, 실제 정의는 `main.c`로 이동.
- 이후 `fcs_common.h`로 공용 구조체를 분리하여 의존성 고리를 끊음.

================================================================================
No.6 | [Comm/Bluetooth] Data Link Layer Failure Analysis
--------------------------------------------------------------------------------
[문제 상황]
- Python Client 앱(`fcs_terminal.py`)에서 보안 패킷을 전송했으나 펌웨어가 응답하지 않음.
- 앱 로그에는 [TX] 패킷이 정상적으로 로깅되지만, [RX]가 전혀 없는 상태.
- Bluetooth 모듈(HC-06)의 LED는 'Connected' 상태로 정상 점멸 중.

[가설 및 검증]
1. 가설 1 (SW/Parser Error): 패킷 파싱 로직에 버그가 있어 데이터를 무시하는가?
   -> 검증: `fcs_core.c`의 `FCS_Task_Serial` 링버퍼 디큐(Dequeue) 지점에 `printf("[RX] %x")` 디버그 코드 삽입.
   -> 결과: PC 터미널에 아무런 로그도 찍히지 않음. 즉, 애플리케이션 레이어로 데이터 자체가 올라오지 않음 (Interrupt 미발생).

2. 가설 2 (HW/Settings): 인터럽트 자체가 꺼져 있는가?
   -> 검증: STM32CubeMX 설정(`.ioc`) 확인.
   -> 결과: `USART1 global interrupt` 항목이 `Disabled`로 설정되어 있음을 발견. (BaudRate 9600은 정상)

[해결 방안]
- STM32CubeMX의 NVIC Settings 탭에서 USART1 인터럽트를 `Enabled`로 변경.
- `main.c`의 초기화 코드에 `FCS_Serial_Start(&huart1)` 추가하여 수신 인터럽트 개방.
- `fcs_core.c`의 응답 함수를 `printf`(Debug Port)에서 `HAL_UART_Transmit(&huart1)`(BT Port)로 변경하여 응답 경로 수정.

[결과]
- 수정 후 Python 앱에서 [ACK] 응답 정상 수신 확인. Azimuth/Elevation 데이터 정상 표출.
================================================================================
